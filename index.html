<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Purple Tic Tac Toe</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap');

  /* --- Body & Layout --- */
  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #6a1b9a, #8e24aa);
    color: #e0c3fc;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    user-select: none;
    overflow-x: hidden;
  }

  h1 {
    font-size: 3rem;
    margin: 20px 0 10px;
    text-shadow: 0 0 10px #cba0f4;
    font-weight: 800;
    letter-spacing: 2px;
  }

  /* --- Controls --- */
  #controls {
    margin: 25px 0;
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
  }

  label {
    font-weight: 700;
    font-size: 1rem;
  }

  select, button {
    border: none;
    border-radius: 20px;
    padding: 10px 20px;
    font-weight: 700;
    cursor: pointer;
    background: linear-gradient(145deg, #9c27b0, #6a1b9a);
    color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: background 0.3s, transform 0.2s;
  }

  select:hover, button:hover {
    background: linear-gradient(145deg, #ab47bc, #8e24aa);
    transform: scale(1.05);
  }

  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  /* --- Game Board --- */
  #game {
    display: grid;
    grid-template-columns: repeat(3, 130px);
    grid-template-rows: repeat(3, 130px);
    gap: 20px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 0 40px rgba(106, 27, 154, 0.4);
  }

  /* --- Cells --- */
  .cell {
    background: linear-gradient(145deg, #ba68c8, #9c27b0);
    border-radius: 18px;
    box-shadow:
      inset 0 0 6px #fff8,
      0 8px 18px rgba(106, 27, 154, 0.4);
    font-size: 4rem;
    font-weight: 900;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    color: #e1bee7;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    user-select: none;
    position: relative;
  }

  .cell:hover:not(.filled):not(.disabled) {
    transform: scale(1.1);
    box-shadow: 0 0 20px 8px #d1c4e9, inset 0 0 10px #b39ddb;
  }

  /* --- Mark Styles --- */
  .cell.x {
    color: #f3e5f5;
    text-shadow: 0 0 10px #ce93d8;
  }
  .cell.o {
    color: #b39ddb;
    text-shadow: 0 0 15px #9575cd;
  }

  /* --- Winning Cells Animation --- */
  .cell.winning {
    animation: pulseGlow 1.5s infinite;
    box-shadow: 0 0 25px 10px #ba68c8;
    color: #ede7f6 !important;
  }

  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 25px 10px #ba68c8; }
    50% { box-shadow: 0 0 40px 15px #ce93d8; }
  }

  /* --- End Game Modal --- */
  #endGameModal {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 340px;
    background: linear-gradient(145deg, #ab47bc, #8e24aa);
    border-radius: 24px;
    padding: 28px;
    color: #fff;
    text-align: center;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    box-shadow: 0 0 30px rgba(106, 27, 154, 0.5);
    transition: opacity 0.35s ease, transform 0.35s ease;
    z-index: 9999;
  }

  #endGameModal.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  #endGameModal h2 {
    margin-bottom: 20px;
    font-size: 1.6rem;
    font-weight: 700;
  }

  #playAgainBtn {
    margin-top: 20px;
    padding: 12px 25px;
    border: none;
    border-radius: 25px;
    background: linear-gradient(145deg, #6a1b9a, #9c27b0);
    color: #fff;
    font-weight: 700;
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: 0 4px 15px rgba(106, 27, 154, 0.3);
    transition: background 0.3s, transform 0.2s;
  }

  #playAgainBtn:hover {
    background: linear-gradient(145deg, #8e24aa, #ab47bc);
    transform: scale(1.05);
  }

  /* --- Confetti Canvas --- */
  #confetti-canvas {
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10000;
    width: 100vw;
    height: 100vh;
  }

  /* --- Responsive --- */
  @media(max-width: 480px) {
    #game {
      grid-template-columns: repeat(3, 90px);
      grid-template-rows: repeat(3, 90px);
      gap: 12px;
      padding: 15px;
    }
    .cell {
      font-size: 3rem;
      border-radius: 14px;
    }
  }
</style>
</head>
<body>

<h1>Ultimate Purple Tic Tac Toe</h1>

<div id="controls" aria-label="Game controls">
  <label for="difficulty">Difficulty:</label>
  <select id="difficulty" aria-controls="game" aria-label="Select AI difficulty">
    <option value="easy">Easy</option>
    <option value="medium" selected>Medium</option>
    <option value="hard">Hard</option>
  </select>
  <button id="undoBtn" aria-label="Undo last move" disabled>Undo</button>
  <button id="redoBtn" aria-label="Redo move" disabled>Redo</button>
  <button id="restartBtn" aria-label="Restart game">Restart</button>
</div>

<div id="game" role="grid" aria-label="Tic Tac Toe Board" tabindex="0">
  <!-- 9 cells -->
  <button class="cell" role="gridcell" aria-label="Row 1 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 1 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 1 Column 3" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 2 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 2 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 2 Column 3" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 3 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 3 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 3 Column 3" tabindex="0"></button>
</div>

<!-- End game modal -->
<div id="endGameModal" role="dialog" aria-modal="true" aria-labelledby="endGameMessage" tabindex="-1">
  <h2 id="endGameMessage"></h2>
  <button id="playAgainBtn">Play Again</button>
</div>

<!-- Confetti canvas -->
<canvas id="confetti-canvas" aria-hidden="true"></canvas>

<script>
  // --- Variables and Game State ---
  const cells = Array.from(document.querySelectorAll('.cell'));
  const game = document.getElementById('game');
  const difficultySelect = document.getElementById('difficulty');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const restartBtn = document.getElementById('restartBtn');
  const modal = document.getElementById('endGameModal');
  const endGameMessage = document.getElementById('endGameMessage');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const confettiCanvas = document.getElementById('confetti-canvas');
  const ctx = confettiCanvas.getContext('2d');

  let board = Array(9).fill(null);
  let playerTurn = true; // player 'X'
  let gameActive = true;
  let moveHistory = [];
  let redoHistory = [];
  let currentDifficulty = difficultySelect.value;
  let winningLine = [];
  let confettiRunning = false;

  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playBeep(frequency = 440, duration = 150) {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.type = 'sine';
    oscillator.frequency.value = frequency;
    oscillator.start();
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + duration / 1000);
  }

  // --- Confetti Particles ---
  class ConfettiParticle {
    constructor(canvasWidth, canvasHeight) {
      this.x = Math.random() * canvasWidth;
      this.y = Math.random() * canvasHeight - canvasHeight;
      this.size = Math.random() * 6 + 4;
      this.gravity = 0.3 + Math.random() * 0.3;
      this.color = `hsl(${Math.random() * 60 + 270}, 80%, 70%)`; // purple hues
      this.rotation = Math.random() * 360;
      this.rotationSpeed = (Math.random() - 0.5) * 10;
      this.velocityX = (Math.random() - 0.5) * 2;
      this.velocityY = Math.random() * 2 + 1;
    }

    update() {
      this.velocityY += this.gravity;
      this.x += this.velocityX;
      this.y += this.velocityY;
      this.rotation += this.rotationSpeed;

      if (this.y > window.innerHeight) {
        this.x = Math.random() * window.innerWidth;
        this.y = -this.size;
        this.velocityY = Math.random() * 2 + 1;
      }
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation * Math.PI / 180);
      ctx.fillStyle = this.color;
      ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
      ctx.restore();
    }
  }

  let confettiParticles = [];

  function setupConfetti() {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    confettiParticles = Array.from({ length: 120 }, () => new ConfettiParticle(confettiCanvas.width, confettiCanvas.height));
  }
  setupConfetti();
  window.addEventListener('resize', setupConfetti);

  function runConfetti() {
    ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    confettiParticles.forEach(p => {
      p.update();
      p.draw(ctx);
    });
    if (confettiRunning) requestAnimationFrame(runConfetti);
  }

  function startConfetti() {
    confettiRunning = true;
    runConfetti();
    setTimeout(() => { confettiRunning = false; ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); }, 5000);
  }

  // --- Game Logic ---
  const winningCombos = [
    [0, 1, 2], [3, 4, 5],
    [6, 7, 8], [0, 3, 6],
    [1, 4, 7], [2, 5, 8],
    [0, 4, 8], [2, 4, 6]
  ];

  function checkWin(board, player) {
    for (const combo of winningCombos) {
      if (combo.every(i => board[i] === player)) {
        return combo;
      }
    }
    return null;
  }

  function checkDraw(board) {
    return board.every(cell => cell !== null);
  }

  function updateBoardUI() {
    cells.forEach((cell, idx) => {
      cell.textContent = board[idx] === 'X' ? 'âœ•' : board[idx] === 'O' ? 'â—¯' : '';
      cell.classList.remove('x', 'o', 'filled', 'winning', 'disabled');
      if (board[idx]) {
        cell.classList.add(board[idx].toLowerCase(), 'filled');
      }
      if (!gameActive) cell.classList.add('disabled');
    });
  }

  function highlightWinningCells(combo) {
    combo.forEach(i => cells[i].classList.add('winning'));
  }

  // --- Undo / Redo ---
  function updateUndoRedoButtons() {
    undoBtn.disabled = moveHistory.length === 0;
    redoBtn.disabled = redoHistory.length === 0;
  }

  // --- Player Move ---
  function playerMove(index) {
    if (!gameActive || board[index]) return false;
    board[index] = 'X';
    moveHistory.push({ board: [...board], player: 'X', index });
    redoHistory = [];
    playBeep(550);
    updateBoardUI();
    if (checkGameStatus('X')) return;
    playerTurn = false;
    aiMove();
    updateUndoRedoButtons();
    return true;
  }

  // --- AI Moves ---
  function aiMove() {
    setTimeout(() => {
      if (!gameActive) return;
      let moveIndex;
      switch (currentDifficulty) {
        case 'easy': moveIndex = easyAIMove(board, 'O'); break;
        case 'medium': moveIndex = mediumAIMove(board, 'O'); break;
        case 'hard': moveIndex = hardAIMove(board, 'O'); break;
        default: moveIndex = mediumAIMove(board, 'O');
      }
      board[moveIndex] = 'O';
      moveHistory.push({ board: [...board], player: 'O', index: moveIndex });
      playBeep(330);
      updateBoardUI();
      checkGameStatus('O');
      playerTurn = true;
      updateUndoRedoButtons();
    }, 700);
  }

  // AI Strategies
  function easyAIMove(board, player) {
    const available = board.map((v, i) => v === null ? i : null).filter(Boolean);
    return available[Math.floor(Math.random() * available.length)];
  }

  function mediumAIMove(board, player) {
    // Win
    for (let i = 0; i < 9; i++) {
      if (!board[i]) {
        board[i] = player;
        if (checkWin(board, player)) {
          board[i] = null; return i;
        }
        board[i] = null;
      }
    }
    // Block
    const opponent = player === 'X' ? 'O' : 'X';
    for (let i = 0; i < 9; i++) {
      if (!board[i]) {
        board[i] = opponent;
        if (checkWin(board, opponent)) {
          board[i] = null; return i;
        }
        board[i] = null;
      }
    }
    // Preferred moves
    const preferred = [4, 0, 2, 6, 8, 1, 3, 5, 7];
    for (let move of preferred) {
      if (!board[move]) return move;
    }
    return easyAIMove(board, player);
  }

  function hardAIMove(board, player) {
    function minimax(newBoard, currentPlayer) {
      const availSpots = newBoard.map((v, i) => v === null ? i : null).filter(Boolean);
      if (checkWin(newBoard, 'X')) return { score: -10 };
      if (checkWin(newBoard, 'O')) return { score: 10 };
      if (availSpots.length === 0) return { score: 0 };

      const moves = [];
      for (const i of availSpots) {
        newBoard[i] = currentPlayer;
        const result = minimax(newBoard, currentPlayer === 'O' ? 'X' : 'O');
        moves.push({ index: i, score: result.score });
        newBoard[i] = null;
      }

      let bestMove;
      if (currentPlayer === 'O') {
        let maxScore = -Infinity;
        for (const move of moves) {
          if (move.score > maxScore) {
            maxScore = move.score;
            bestMove = move;
          }
        }
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          if (move.score < minScore) {
            minScore = move.score;
            bestMove = move;
          }
        }
      }
      return bestMove;
    }
    const best = minimax([...board], player);
    return best.index;
  }

  // --- Game Status ---
  function checkGameStatus(currentPlayer) {
    const winCombo = checkWin(board, currentPlayer);
    if (winCombo) {
      gameActive = false;
      highlightWinningCells(winCombo);
      showEndGameModal(`${currentPlayer === 'X' ? 'You Win! ðŸŽ‰' : 'AI Wins! ðŸ’»'}`);
      startConfetti();
      return true;
    } else if (checkDraw(board)) {
      gameActive = false;
      showEndGameModal("It's a Draw! ðŸ¤");
      return true;
    }
    return false;
  }

  // --- Modal ---
  function showEndGameModal(message) {
    endGameMessage.textContent = message;
    modal.classList.add('show');
    modal.focus();
  }

  function hideEndGameModal() {
    modal.classList.remove('show');
    game.focus();
  }

  // --- Undo / Redo ---
  function undoMove() {
    if (moveHistory.length === 0) return;
    const last = moveHistory.pop();
    redoHistory.push(last);
    if (moveHistory.length === 0) {
      board = Array(9).fill(null);
      gameActive = true;
      playerTurn = true;
    } else {
      board = [...moveHistory[moveHistory.length - 1].board];
      gameActive = true;
      playerTurn = moveHistory[moveHistory.length - 1].player === 'X';
    }
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  function redoMove() {
    if (redoHistory.length === 0) return;
    const next = redoHistory.pop();
    moveHistory.push(next);
    board = [...next.board];
    gameActive = true;
    playerTurn = next.player === 'X';
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  function restartGame() {
    board = Array(9).fill(null);
    moveHistory = [];
    redoHistory = [];
    gameActive = true;
    playerTurn = true;
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  // --- Event Listeners ---
  cells.forEach((cell, i) => {
    cell.addEventListener('click', () => { if (playerTurn) playerMove(i); });
    cell.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (playerTurn) playerMove(i);
      }
    });
  });

  document.getElementById('undoBtn').addEventListener('click', undoMove);
  document.getElementById('redoBtn').addEventListener('click', redoMove);
  document.getElementById('restartBtn').addEventListener('click', restartGame);
  difficultySelect.addEventListener('change', e => {
    currentDifficulty = e.target.value;
  });

  document.getElementById('playAgainBtn').addEventListener('click', () => {
    restartGame();
  });

  // Accessibility: trap focus inside modal
  modal.addEventListener('keydown', e => {
    if (e.key === 'Escape') {
      e.preventDefault();
      hideEndGameModal();
    }
    if (e.key === 'Tab') {
      e.preventDefault();
      playAgainBtn.focus();
    }
  });

  // --- Initialize ---
  updateBoardUI();
  updateUndoRedoButtons();

  // --- Confetti ---
  const ctx = document.getElementById('confetti-canvas').getContext('2d');
  let particles = [];

  class Particle {
    constructor() {
      this.reset();
    }

    reset() {
      this.x = Math.random() * window.innerWidth;
      this.y = Math.random() * -window.innerHeight;
      this.size = Math.random() * 4 + 2;
      this.color = `hsl(${Math.random() * 60 + 270}, 80%, 70%)`;
      this.velocityX = (Math.random() - 0.5) * 2;
      this.velocityY = Math.random() * 2 + 1;
      this.rotation = Math.random() * 360;
      this.rotationSpeed = (Math.random() - 0.5) * 10;
    }

    update() {
      this.velocityY += 0.2;
      this.x += this.velocityX;
      this.y += this.velocityY;
      this.rotation += this.rotationSpeed;
      if (this.y > window.innerHeight + this.size) {
        this.reset();
        this.y = -this.size;
      }
    }

    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation * Math.PI / 180);
      ctx.fillStyle = this.color;
      ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
      ctx.restore();
    }
  }

  function initConfetti() {
    particles = Array.from({ length: 150 }, () => new Particle());
  }

  function animateConfetti() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    particles.forEach(p => {
      p.update();
      p.draw();
    });
    if (confettiRunning) requestAnimationFrame(animateConfetti);
  }

  function startConfetti() {
    confettiRunning = true;
    animateConfetti();
    setTimeout(() => {
      confettiRunning = false;
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }, 4000);
  }

  window.addEventListener('resize', initConfetti);
  initConfetti();

</script>
</body>
</html>

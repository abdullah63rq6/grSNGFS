<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Tic Tac Toe</title>
<style>
  /* Reset & base */
  * {
    box-sizing: border-box;
  }
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
  }

  h1 {
    margin-bottom: 0.5rem;
    color: #b388ff;
    text-shadow: 0 0 5px #7c4dffaa;
  }

  /* Controls */
  #controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 1rem;
    justify-content: center;
    align-items: center;
  }
  label {
    font-size: 1rem;
  }
  select, button {
    font-size: 1rem;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: background-color 0.3s ease;
  }
  select {
    background: #2a2a2a;
    color: #eee;
  }
  button {
    background: #7c4dff;
    color: #fff;
    font-weight: 600;
    user-select: none;
  }
  button:disabled {
    background: #444;
    cursor: not-allowed;
  }
  button:hover:not(:disabled),
  select:hover {
    background: #9f7eff;
  }

  /* Timer */
  #timer {
    font-weight: 600;
    font-size: 1.1rem;
    margin-left: 1rem;
    min-width: 220px;
    text-align: center;
  }

  /* Scoreboard */
  #scoreboard {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }
  .player-score {
    background: #222;
    padding: 0.7rem 1rem;
    border-radius: 12px;
    width: 130px;
    text-align: center;
    box-shadow: 0 0 10px #0008 inset;
  }
  .player-score > div {
    margin: 0.15rem 0;
  }
  .player-symbol {
    font-size: 2rem;
    line-height: 1;
  }
  .level-badge {
    font-weight: 700;
    font-size: 0.9rem;
    margin-top: 0.3rem;
    color: #b388ff;
  }

  /* Game board */
  #game {
    display: grid;
    gap: 6px;
    max-width: 400px;
    max-height: 400px;
    width: 100vw;
    max-width: 400px;
    aspect-ratio: 1;
  }
  .cell {
    background: #2a2a2a;
    border-radius: 10px;
    border: 2px solid #444;
    font-size: 2.6rem;
    font-weight: 900;
    color: #eee;
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  .cell:hover:not(:disabled) {
    background-color: #4a3f7f;
  }
  .cell:focus-visible {
    outline: 3px solid #b388ff;
    outline-offset: 2px;
  }
  .cell.filled.player-0 { color: #d1a3ff; }
  .cell.filled.player-1 { color: #512da8; }
  .cell.filled.player-2 { color: #ffbb55; }
  .cell.filled.player-3 { color: #66ffcc; }
  .cell.blocked {
    background: #551a8b66;
    cursor: not-allowed;
    color: #bbb;
    border-color: #7700ffbb;
  }

  /* Modal */
  #endGameModal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #000d;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }
  #endGameModal.show {
    display: flex;
  }
  #endGameModal > div {
    background: #2a1a5b;
    border-radius: 12px;
    padding: 2rem 3rem;
    text-align: center;
    box-shadow: 0 0 20px #7c4dffcc;
  }
  #endGameTitle {
    font-size: 2rem;
    margin-bottom: 1rem;
    color: #d1a3ff;
  }
  #restartBtn {
    background: #7c4dff;
    padding: 0.7rem 2rem;
    font-size: 1.2rem;
    border-radius: 12px;
    border: none;
    color: white;
    font-weight: 700;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.3s ease;
  }
  #restartBtn:hover {
    background: #9f7eff;
  }

  /* Confetti canvas */
  #confetti-canvas {
    pointer-events: none;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 5;
  }

  /* Responsive */
  @media (max-width: 480px) {
    #controls {
      flex-direction: column;
      gap: 0.8rem;
    }
    #timer {
      min-width: auto;
      margin-left: 0;
      margin-top: 0.5rem;
    }
  }
</style>
</head>
<body>

<h1>Advanced Tic Tac Toe</h1>

<!-- Controls -->
<div id="controls" role="region" aria-label="Game settings and controls">
  <label for="boardSize">Board Size:</label>
  <select id="boardSize" aria-describedby="boardSizeDesc" aria-label="Select board size">
    <option value="3">3 x 3</option>
    <option value="4">4 x 4</option>
    <option value="5">5 x 5</option>
  </select>
  <span id="boardSizeDesc" class="sr-only">Choose board dimension</span>

  <label for="playerCount">Players:</label>
  <select id="playerCount" aria-describedby="playerCountDesc" aria-label="Select number of players">
    <option value="2">2 Players</option>
    <option value="3">3 Players</option>
    <option value="4">4 Players</option>
  </select>
  <span id="playerCountDesc" class="sr-only">Choose number of players</span>

  <button id="startBtn" aria-label="Start new game">Start Game</button>
  <button id="powerupBtn" aria-label="Use power-up" disabled>Use Power-Up</button>

  <div id="timer" aria-live="polite" aria-atomic="true" role="status" style="min-width:250px;"></div>
</div>

<!-- Scoreboard -->
<div id="scoreboard" aria-label="Player scores"></div>

<!-- Game Board -->
<div id="game" role="grid" aria-label="Tic Tac Toe Board"></div>

<!-- End Game Modal -->
<div id="endGameModal" role="dialog" aria-modal="true" aria-labelledby="endGameTitle" tabindex="-1">
  <div>
    <h2 id="endGameTitle"></h2>
    <button id="restartBtn" aria-label="Restart game">Play Again</button>
  </div>
</div>

<!-- Confetti Canvas -->
<canvas id="confetti-canvas"></canvas>

<script>
(() => {
  'use strict';

  // --- Constants ---
  const PLAYER_SYMBOLS = [
    ['\u2715', '\u2A2F'],    // Player 1: X and variant
    ['\u25EF', '\u25CB'],    // Player 2: O and variant
    ['\u2605', '\u272D'],    // Player 3: Star symbols
    ['\u25B2', '\u25BC']     // Player 4: Triangles
  ];

  const PLAYER_COLORS = ['#d1a3ff', '#512da8', '#ffbb55', '#66ffcc'];

  const WIN_LEVELS = [0, 3, 5, 8]; // Wins required for level badges

  const MOVE_TIME_LIMIT = 15; // seconds per move

  // --- DOM Elements ---
  const gameBoard = document.getElementById('game');
  const startBtn = document.getElementById('startBtn');
  const powerupBtn = document.getElementById('powerupBtn');
  const boardSizeSelect = document.getElementById('boardSize');
  const playerCountSelect = document.getElementById('playerCount');
  const scoreboard = document.getElementById('scoreboard');
  const timerDisplay = document.getElementById('timer');
  const endGameModal = document.getElementById('endGameModal');
  const endGameTitle = document.getElementById('endGameTitle');
  const restartBtn = document.getElementById('restartBtn');
  const confettiCanvas = document.getElementById('confetti-canvas');

  // --- Game State ---
  let boardSize = 3;
  let playerCount = 2;
  let board = [];
  let currentPlayer = 0;
  let movesMade = 0;
  let moveTimer = null;
  let moveTimeLeft = MOVE_TIME_LIMIT;
  let lastMoves = [];       // last move index per player for power-up erase
  let powerupsLeft = [];    // power-up count per player
  let blockedCells = new Set();
  let scores = [];
  let gameActive = false;

  // Confetti animation state
  let confettiCtx, confettiWidth, confettiHeight, confettiPieces;

  // --- Functions ---

  function initScores() {
    scores = Array(playerCount).fill(0);
    powerupsLeft = Array(playerCount).fill(1); // 1 power-up each
    lastMoves = Array(playerCount).fill(null);
    updateScoreboard();
  }

  function updateScoreboard() {
    scoreboard.innerHTML = '';
    for(let i = 0; i < playerCount; i++) {
      const div = document.createElement('div');
      div.className = 'player-score';
      div.style.color = PLAYER_COLORS[i];
      div.innerHTML = `
        <div class="player-symbol player-${i}" aria-label="Player ${i+1} symbol">${PLAYER_SYMBOLS[i][0]}</div>
        <div>Player ${i+1}</div>
        <div>Wins: ${scores[i]}</div>
        <div class="level-badge">${getLevelBadge(scores[i])}</div>
        <div>Power-Ups: ${powerupsLeft[i]}</div>
      `;
      scoreboard.appendChild(div);
    }
  }

  function getLevelBadge(wins) {
    if (wins >= WIN_LEVELS[3]) return 'Legend 🏆';
    if (wins >= WIN_LEVELS[2]) return 'Pro ⭐';
    if (wins >= WIN_LEVELS[1]) return 'Rookie 🔰';
    return 'Newbie';
  }

  function createEmptyBoard() {
    board = Array(boardSize * boardSize).fill(null);
    blockedCells.clear();
  }

  function setupGrid() {
    gameBoard.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
    gameBoard.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;
  }

  function renderBoard() {
    gameBoard.innerHTML = '';
    for(let i = 0; i < board.length; i++) {
      const cell = document.createElement('button');
      cell.className = 'cell';
      cell.setAttribute('role', 'gridcell');
      cell.setAttribute('aria-label', `Row ${Math.floor(i/boardSize)+1}, Column ${i % boardSize + 1}`);
      cell.dataset.index = i;

      if(blockedCells.has(i)) {
        cell.classList.add('blocked');
        cell.disabled = true;
      }

      if(board[i] !== null) {
        cell.textContent = PLAYER_SYMBOLS[board[i]][0];
        cell.classList.add('filled', `player-${board[i]}`);
        cell.disabled = true;
      }

      gameBoard.appendChild(cell);
    }
  }

  function startTimer() {
    clearInterval(moveTimer);
    moveTimeLeft = MOVE_TIME_LIMIT;
    updateTimerDisplay();
    moveTimer = setInterval(() => {
      moveTimeLeft--;
      updateTimerDisplay();
      if(moveTimeLeft <= 0) {
        clearInterval(moveTimer);
        alert(`Time's up for Player ${currentPlayer + 1}! Turn skipped.`);
        nextTurn();
      }
    }, 1000);
  }

  function updateTimerDisplay() {
    timerDisplay.textContent = `Player ${currentPlayer + 1} (${PLAYER_SYMBOLS[currentPlayer][0]}) time left: ${moveTimeLeft}s`;
    timerDisplay.style.color = PLAYER_COLORS[currentPlayer];
  }

  function handleCellClick(e) {
    if (!gameActive) return;
    const idx = parseInt(e.target.dataset.index);
    if(board[idx] !== null || blockedCells.has(idx)) return;

    makeMove(idx, currentPlayer);
  }

  function makeMove(idx, player) {
    board[idx] = player;
    lastMoves[player] = idx;
    movesMade++;
    renderBoard();

    if(checkWin(idx, player)) {
      scores[player]++;
      updateScoreboard();
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal(`Player ${player + 1} Wins!`);
      launchConfetti();
    } else if(movesMade >= board.length - blockedCells.size) {
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal(`It's a Tie!`);
    } else {
      if (movesMade % 5 === 0) {
        blockRandomCell();
      }
      nextTurn();
    }
  }

  function nextTurn() {
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    currentPlayer = (currentPlayer + 1) % playerCount;

    let looped = 0;
    while(looped < playerCount && isPlayerStuck(currentPlayer)) {
      currentPlayer = (currentPlayer + 1) % playerCount;
      looped++;
    }
    if(looped === playerCount) {
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal("No moves left! It's a Tie!");
      return;
    }
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    updateTimerDisplay();
    startTimer();
  }

  function isPlayerStuck(player) {
    return board.every((val, idx) => val !== null || blockedCells.has(idx));
  }

  function checkWin(idx, player) {
    const row = Math.floor(idx / boardSize);
    const col = idx % boardSize;
    const winLength = boardSize;

    function countDirection(dx, dy) {
      let count = 1;
      for(let step = 1; step < winLength; step++) {
        const nx = col + dx*step;
        const ny = row + dy*step;
        if(nx < 0 || ny < 0 || nx >= boardSize || ny >= boardSize) break;
        if(board[ny*boardSize + nx] === player) count++;
        else break;
      }
      for(let step = 1; step < winLength; step++) {
        const nx = col - dx*step;
        const ny = row - dy*step;
        if(nx < 0 || ny < 0 || nx >= boardSize || ny >= boardSize) break;
        if(board[ny*boardSize + nx] === player) count++;
        else break;
      }
      return count >= winLength;
    }

    // Check rows, columns, and diagonals
    return (
      countDirection(1, 0) || // horizontal
      countDirection(0, 1) || // vertical
      countDirection(1, 1) || // diagonal down-right
      countDirection(1, -1)   // diagonal up-right
    );
  }

  // Power-up: erase opponent's last move
  function usePowerUp() {
    if(!gameActive || powerupsLeft[currentPlayer] <= 0) return;
    // Find last opponent move to erase
    for(let i=1; i<playerCount; i++) {
      let opponent = (currentPlayer + i) % playerCount;
      const idx = lastMoves[opponent];
      if(idx !== null && board[idx] === opponent) {
        board[idx] = null;
        lastMoves[opponent] = null;
        powerupsLeft[currentPlayer]--;
        renderBoard();
        updateScoreboard();
        powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
        alert(`Player ${currentPlayer + 1} used power-up to erase Player ${opponent + 1}'s last move!`);
        return;
      }
    }
    alert("No opponent moves to erase!");
  }

  // Block a random free cell for 2 turns
  let blockTurnCounter = new Map();
  function blockRandomCell() {
    const freeCells = [];
    board.forEach((val, idx) => {
      if(val === null && !blockedCells.has(idx)) freeCells.push(idx);
    });
    if(freeCells.length === 0) return;

    const cellToBlock = freeCells[Math.floor(Math.random() * freeCells.length)];
    blockedCells.add(cellToBlock);
    blockTurnCounter.set(cellToBlock, 2);
    renderBoard();
  }

  function decrementBlockedCells() {
    for (const [cell, turns] of blockTurnCounter.entries()) {
      if (turns <= 1) {
        blockedCells.delete(cell);
        blockTurnCounter.delete(cell);
      } else {
        blockTurnCounter.set(cell, turns - 1);
      }
    }
    renderBoard();
  }

  // End game modal
  function showEndGameModal(message) {
    endGameTitle.textContent = message;
    endGameModal.classList.add('show');
    endGameModal.focus();
  }

  function hideEndGameModal() {
    endGameModal.classList.remove('show');
  }

  // Confetti animation adapted from a simple JS confetti snippet
  function launchConfetti() {
    confettiCtx = confettiCanvas.getContext('2d');
    confettiWidth = confettiCanvas.width = window.innerWidth;
    confettiHeight = confettiCanvas.height = window.innerHeight;

    confettiPieces = [];
    const colors = PLAYER_COLORS.slice(0, playerCount);

    for(let i = 0; i < 150; i++) {
      confettiPieces.push({
        x: Math.random() * confettiWidth,
        y: Math.random() * confettiHeight - confettiHeight,
        r: (Math.random() * 6) + 4,
        d: (Math.random() * 15) + 10,
        color: colors[Math.floor(Math.random() * colors.length)],
        tilt: Math.floor(Math.random() * 10) - 10,
        tiltAngle: 0,
        tiltAngleIncrement: (Math.random() * 0.07) + 0.05
      });
    }
    (function runConfetti() {
      confettiCtx.clearRect(0, 0, confettiWidth, confettiHeight);
      confettiPieces.forEach((p, i) => {
        p.tiltAngle += p.tiltAngleIncrement;
        p.y += (Math.cos(p.d) + 3 + p.r / 2) / 2;
        p.x += Math.sin(p.tiltAngle);
        p.tilt = Math.sin(p.tiltAngle) * 15;

        confettiCtx.fillStyle = p.color;
        confettiCtx.beginPath();
        confettiCtx.moveTo(p.x + p.tilt + p.r / 2, p.y);
        confettiCtx.lineTo(p.x + p.tilt, p.y + p.tilt + p.r / 2);
        confettiCtx.lineTo(p.x + p.tilt - p.r / 2, p.y);
        confettiCtx.lineTo(p.x + p.tilt, p.y - p.tilt - p.r / 2);
        confettiCtx.closePath();
        confettiCtx.fill();

        if(p.y > confettiHeight) {
          confettiPieces[i] = {
            x: Math.random() * confettiWidth,
            y: -10,
            r: p.r,
            d: p.d,
            color: p.color,
            tilt: p.tilt,
            tiltAngle: 0,
            tiltAngleIncrement: p.tiltAngleIncrement
          };
        }
      });
      if(gameActive) {
        requestAnimationFrame(runConfetti);
      } else {
        confettiCtx.clearRect(0, 0, confettiWidth, confettiHeight);
      }
    })();
  }

  // Keyboard navigation for board
  gameBoard.addEventListener('keydown', (e) => {
    if (!gameActive) return;
    const active = document.activeElement;
    if (!active.classList.contains('cell')) return;

    const idx = Number(active.dataset.index);
    let targetIdx = null;

    switch(e.key) {
      case 'ArrowRight':
        targetIdx = (idx % boardSize === boardSize - 1) ? idx - (boardSize - 1) : idx + 1;
        break;
      case 'ArrowLeft':
        targetIdx = (idx % boardSize === 0) ? idx + (boardSize - 1) : idx - 1;
        break;
      case 'ArrowDown':
        targetIdx = (idx + boardSize >= board.length) ? idx % boardSize : idx + boardSize;
        break;
      case 'ArrowUp':
        targetIdx = (idx - boardSize < 0) ? (board.length - boardSize + idx % boardSize) : idx - boardSize;
        break;
      case 'Enter':
      case ' ':
        active.click();
        e.preventDefault();
        return;
    }

    if(targetIdx !== null) {
      const targetCell = gameBoard.querySelector(`.cell[data-index="${targetIdx}"]`);
      if(targetCell) {
        targetCell.focus();
        e.preventDefault();
      }
    }
  });

  // Event Listeners

  startBtn.addEventListener('click', () => {
    boardSize = parseInt(boardSizeSelect.value);
    playerCount = parseInt(playerCountSelect.value);

    createEmptyBoard();
    setupGrid();
    renderBoard();
    initScores();

    currentPlayer = 0;
    movesMade = 0;
    gameActive = true;
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;

    startTimer();
    hideEndGameModal();
  });

  gameBoard.addEventListener('click', (e) => {
    if(e.target.classList.contains('cell') && !e.target.disabled) {
      handleCellClick(e);
    }
  });

  powerupBtn.addEventListener('click', () => {
    usePowerUp();
  });

  restartBtn.addEventListener('click', () => {
    hideEndGameModal();
    startBtn.click();
  });

  // Every turn decrement blocked cells turn count
  setInterval(() => {
    if(gameActive) decrementBlockedCells();
  }, 3000);

  // Initial focus on controls for keyboard users
  boardSizeSelect.focus();

})();
</script>

</body>
</html>

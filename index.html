<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Advanced Tic Tac Toe</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f3e8ff;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 25px;
    margin: 0;
    color: #4b0082;
    user-select: none;
  }

  h1 {
    margin-bottom: 10px;
    color: #6a0dad;
  }

  #settings {
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
  }

  label {
    margin-right: 10px;
  }

  select, button {
    padding: 6px 12px;
    margin-right: 15px;
    font-size: 1rem;
    border-radius: 6px;
    border: 1.5px solid #8a2be2;
    cursor: pointer;
    background-color: #9370db;
    color: white;
    transition: background-color 0.3s ease;
  }

  select:hover, button:hover {
    background-color: #7b68ee;
  }

  #game {
    display: grid;
    grid-template-columns: repeat(3, 110px);
    grid-template-rows: repeat(3, 110px);
    gap: 12px;
  }

  .cell {
    background: #dda0dd;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    font-size: 3.8rem;
    font-weight: 900;
    color: #4b0082;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.25s ease, transform 0.15s ease;
  }

  .cell:hover:not(.disabled):not(.filled) {
    background-color: #d8bfd8;
    transform: scale(1.05);
  }

  .cell.x {
    color: #8a2be2;
  }

  .cell.o {
    color: #9400d3;
  }

  .cell.winning {
    background-color: #ba55d3 !important;
    color: #4b0082 !important;
    box-shadow: 0 0 15px 3px #8a2be2;
    cursor: default;
  }

  .cell.disabled {
    cursor: default;
  }

  #status {
    margin-top: 20px;
    font-size: 1.5rem;
    min-height: 42px;
    font-weight: 600;
  }

  #restartBtn, #undoBtn {
    margin-top: 15px;
    padding: 10px 28px;
    font-size: 1rem;
    border: none;
    border-radius: 25px;
    background-color: #8a2be2;
    color: white;
    cursor: pointer;
    box-shadow: 0 5px 12px rgba(138, 43, 226, 0.5);
    transition: background-color 0.3s ease;
    margin-right: 15px;
  }

  #restartBtn:hover, #undoBtn:hover {
    background-color: #6a0dad;
  }

  #scoreboard {
    margin-top: 20px;
    font-size: 1.2rem;
  }

  #scoreboard span {
    margin-right: 20px;
    font-weight: 600;
  }

  #timer {
    margin-top: 12px;
    font-size: 1.25rem;
    font-weight: 600;
    color: #555;
  }

  #history {
    margin-top: 20px;
    width: 350px;
    max-width: 90vw;
    background: #fff0ff;
    border-radius: 8px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    padding: 12px;
    font-size: 0.95rem;
    max-height: 150px;
    overflow-y: auto;
  }

  #history h3 {
    margin-top: 0;
    margin-bottom: 8px;
    font-weight: 700;
    text-align: center;
    color: #6a0dad;
  }

  #history ul {
    list-style-type: none;
    padding-left: 10px;
    margin: 0;
  }

  #history ul li {
    padding: 3px 0;
    border-bottom: 1px solid #eee;
  }

  /* Confetti styles */
  #confetti-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9999;
  }
</style>
</head>
<body>

<h1>Advanced Tic Tac Toe</h1>

<div id="settings">
  <label for="mode">Play Mode:</label>
  <select id="mode">
    <option value="human">Human vs Human</option>
    <option value="easy">Human vs AI (Easy)</option>
    <option value="hard">Human vs AI (Hard)</option>
  </select>

  <label for="winsToWin">Wins to Win:</label>
  <select id="winsToWin">
    <option value="3">3</option>
    <option value="4">4</option>
    <option value="5" selected>5</option>
    <option value="6">6</option>
  </select>

  <button id="restartBtn">Restart Game</button>
  <button id="undoBtn" disabled>Undo Last Move</button>
</div>

<div id="status">Player X's turn</div>
<div id="timer">Time left: 10s</div>

<div id="game"></div>

<!-- Confetti Canvas -->
<canvas id="confetti-canvas"></canvas>

<div id="scoreboard">
  <span>Player X Wins: <span id="scoreX">0</span></span>
  <span>Player O Wins: <span id="scoreO">0</span></span>
  <span>Draws: <span id="scoreDraw">0</span></span>
</div>

<div id="history">
  <h3>Game History</h3>
  <ul id="moveList"></ul>
</div>

<script>
  const gameContainer = document.getElementById('game');
  const statusDiv = document.getElementById('status');
  const restartBtn = document.getElementById('restartBtn');
  const undoBtn = document.getElementById('undoBtn');
  const modeSelect = document.getElementById('mode');
  const winsToWinSelect = document.getElementById('winsToWin');
  const timerDiv = document.getElementById('timer');
  const scoreXSpan = document.getElementById('scoreX');
  const scoreOSpan = document.getElementById('scoreO');
  const scoreDrawSpan = document.getElementById('scoreDraw');
  const moveList = document.getElementById('moveList');
  const confettiCanvas = document.getElementById('confetti-canvas');

  let board = ['', '', '', '', '', '', '', '', ''];
  let currentPlayer = 'X';
  let gameActive = true;
  let moveHistory = [];
  let scores = { X: 0, O: 0, Draw: 0 };
  let timer = 10;
  let timerInterval = null;

  // Game configuration
  let winsToWin = parseInt(winsToWinSelect.value);

  // Winning combos
  const winningConditions = [
    [0,1,2], [3,4,5], [6,7,8], // rows
    [0,3,6], [1,4,7], [2,5,8], // columns
    [0,4,8], [2,4,6]           // diagonals
  ];

  // Confetti setup
  const ctx = confettiCanvas.getContext('2d');
  confettiCanvas.width = window.innerWidth;
  confettiCanvas.height = window.innerHeight;

  window.addEventListener('resize', () => {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  });

  let confettiParticles = [];

  function createConfetti() {
    for(let i=0; i<150; i++) {
      confettiParticles.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * -window.innerHeight,
        r: Math.random() * 4 + 1,
        d: Math.random() * 4 + 1,
        color: `hsl(${Math.random()*360}, 70%, 60%)`,
        tilt: Math.random() * 10 - 5,
        tiltAngle: Math.random() * Math.PI * 2,
        tiltSpeed: Math.random() * 0.02 + 0.01
      });
    }
  }

  function drawConfetti() {
    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    for(let i=0; i<confettiParticles.length; i++) {
      let p = confettiParticles[i];
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.fill();

      p.tiltAngle += p.tiltSpeed;
      p.tilt = Math.sin(p.tiltAngle) * 15;

      p.x += Math.sin(p.tiltAngle) * p.d;
      p.y += p.d;

      if(p.y > window.innerHeight) {
        p.x = Math.random() * window.innerWidth;
        p.y = -10;
      }
    }
    requestAnimationFrame(drawConfetti);
  }

  function launchConfetti() {
    createConfetti();
    drawConfetti();

    // Stop confetti after 2 seconds
    setTimeout(() => {
      confettiParticles = [];
      ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
    }, 2000);
  }

  // Initialize board
  function createBoard() {
    gameContainer.innerHTML = '';
    for(let i = 0; i < 9; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      cell.addEventListener('click', handleCellClick);
      gameContainer.appendChild(cell);
    }
  }

  // Handle clicks on cells
  function handleCellClick(e) {
    if (!gameActive) return;
    const index = e.target.dataset.index;
    if (board[index] !== '') return;

    makeMove(index, currentPlayer);
  }

  // Make a move on board and update UI/history
  function makeMove(index, player) {
    board[index] = player;
    const cell = gameContainer.querySelector(`.cell[data-index="${index}"]`);
    cell.textContent = player;
    cell.classList.add(player.toLowerCase(), 'filled');
    moveHistory.push({ index, player });
    undoBtn.disabled = false;

    checkResult();
  }

  // Switch player
  function switchPlayer() {
    currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
    statusDiv.textContent = `Player ${currentPlayer}'s turn`;
    resetTimer();
  }

  // Check for win or draw
  function checkResult() {
    for (const condition of winningConditions) {
      const [a,b,c] = condition;
      if (board[a] && board[a] === board[b] && board[b] === board[c]) {
        // Win detected
        highlightCells(condition);
        gameActive = false;
        statusDiv.textContent = `Player ${currentPlayer} wins! ðŸŽ‰`;
        scores[currentPlayer]++;
        updateScoreboard();
        launchConfetti();
        checkMatchWin();
        stopTimer();
        sounds.win.play();
        logMove(`Player ${currentPlayer} wins!`);
        return;
      }
    }

    if (!board.includes('')) {
      // Draw
      gameActive = false;
      statusDiv.textContent = `It's a draw! ðŸ¤`;
      scores.Draw++;
      updateScoreboard();
      restartBtn.style.display = 'inline-block';
      undoBtn.disabled = true;
      stopTimer();
      sounds.draw.play();
      logMove(`Game ended in a draw.`);
      return;
    }

    // Continue game
    switchPlayer();

    // If AI turn, make AI move
    if (gameActive && isAITurn()) {
      disableBoard(true);
      setTimeout(() => {
        aiMakeMove();
        disableBoard(false);
      }, 600);
    }
  }

  // Highlight winning cells
  function highlightCells(indices) {
    indices.forEach(i => {
      const cell = gameContainer.querySelector(`.cell[data-index="${i}"]`);
      if (cell) {
        cell.classList.add('winning');
        cell.classList.remove('filled');
        cell.classList.add('disabled');
      }
    });
  }

  // Update scoreboard UI
  function updateScoreboard() {
    scoreXSpan.textContent = scores.X;
    scoreOSpan.textContent = scores.O;
    scoreDrawSpan.textContent = scores.Draw;
  }

  // Check if player has won the match
  function checkMatchWin() {
    if (scores.X >= winsToWin || scores.O >= winsToWin) {
      gameActive = false;
      const winner = scores.X >= winsToWin ? 'X' : 'O';
      statusDiv.textContent = `Player ${winner} wins the match! ðŸ†`;
      // Optionally, disable restart or reset scores
    } else {
      // Show restart button to continue
      restartBtn.style.display = 'inline-block';
    }
  }

  // Restart game
  function restartGame() {
    board.fill('');
    currentPlayer = 'X';
    gameActive = true;
    moveHistory = [];
    statusDiv.textContent = `Player ${currentPlayer}'s turn`;
    restartBtn.style.display = 'none';
    undoBtn.disabled = true;
    timerDiv.textContent = `Time left: 10s`;
    createBoard();
    resetTimer();
    moveList.innerHTML = '';
    if (isAITurn()) {
      disableBoard(true);
      setTimeout(() => {
        aiMakeMove();
        disableBoard(false);
      }, 600);
    }
  }

  // Undo last move
  function undoLastMove() {
    if (moveHistory.length === 0 || !gameActive) return;

    const lastMove = moveHistory.pop();
    board[lastMove.index] = '';
    const cell = gameContainer.querySelector(`.cell[data-index="${lastMove.index}"]`);
    cell.textContent = '';
    cell.classList.remove('x', 'o', 'filled');

    // Undo AI move if applicable
    if (modeSelect.value !== 'human' && moveHistory.length > 0) {
      const prevMove = moveHistory.pop();
      board[prevMove.index] = '';
      const cell2 = document.querySelector(`.cell[data-index="${prevMove.index}"]`);
      cell2.textContent = '';
      cell2.classList.remove('x', 'o', 'filled');
      currentPlayer = prevMove.player;
    } else {
      currentPlayer = lastMove.player;
    }

    statusDiv.textContent = `Player ${currentPlayer}'s turn`;
    undoBtn.disabled = moveHistory.length === 0;
    gameActive = true;
    restartBtn.style.display = 'none';
    resetTimer();
    removeHighlights();
    removeDisabled();
  }

  // Remove highlights
  function removeHighlights() {
    document.querySelectorAll('.winning').forEach(c => c.classList.remove('winning'));
  }

  // Disable or enable board clicks
  function disableBoard(disable) {
    document.querySelectorAll('.cell').forEach(cell => {
      if (disable) {
        cell.classList.add('disabled');
      } else {
        cell.classList.remove('disabled');
      }
    });
  }

  // AI logic
  function isAITurn() {
    return (modeSelect.value !== 'human' && currentPlayer === 'O');
  }

  function aiMakeMove() {
    if (!gameActive) return;

    let index;
    if (modeSelect.value === 'easy') {
      index = getRandomMove();
    } else {
      index = getBestMove(board, currentPlayer);
    }

    makeMove(index, currentPlayer);
  }

  function getRandomMove() {
    const emptyCells = board.map((v,i) => v === '' ? i : null).filter(v => v !== null);
    return emptyCells[Math.floor(Math.random() * emptyCells.length)];
  }

  // Hard AI - Minimax
  function getBestMove(boardState, player) {
    function minimax(b, depth, isMax) {
      const winner = checkWinner(b);
      if (winner !== null) {
        if (winner === 'X') return { score: -10 + depth };
        if (winner === 'O') return { score: 10 - depth };
        if (winner === 'Draw') return { score: 0 };
      }

      let bestScore = isMax ? -Infinity : Infinity;
      let move = null;

      for (let i=0; i<9; i++) {
        if (b[i] === '') {
          b[i] = isMax ? 'O' : 'X';
          const result = minimax(b, depth+1, !isMax);
          b[i] = '';
          if (isMax && result.score > bestScore) {
            bestScore = result.score;
            move = i;
          } else if (!isMax && result.score < bestScore) {
            bestScore = result.score;
            move = i;
          }
        }
      }
      return { score: bestScore, index: move };
    }

    return minimax(boardState.slice(), 0, true).index;
  }

  function checkWinner(b) {
    for (const cond of winningConditions) {
      const [a, bIdx, c] = cond;
      if (b[a] && b[a] === b[bIdx] && b[bIdx] === b[c]) {
        return b[a];
      }
    }
    if (!b.includes('')) return 'Draw';
    return null;
  }

  // Timer
  function resetTimer() {
    timer = 10;
    timerDiv.textContent = `Time left: ${timer}s`;
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      timer--;
      timerDiv.textContent = `Time left: ${timer}s`;
      if(timer <= 0) {
        clearInterval(timerInterval);
        timerDiv.textContent = `Time's up!`;
        if(gameActive) {
          if(modeSelect.value === 'human') {
            statusDiv.textContent = `Player ${currentPlayer} ran out of time! Turn forfeited.`;
            switchPlayer();
          } else {
            // AI wins if human runs out of time
            gameActive = false;
            statusDiv.textContent = `Player ${currentPlayer} ran out of time! Game over.`;
            scores[currentPlayer === 'X' ? 'O' : 'X']++;
            updateScoreboard();
            checkMatchWin();
            restartBtn.style.display = 'inline-block';
            undoBtn.disabled = true;
          }
        }
      }
    }, 1000);
  }

  function stopTimer() {
    if(timerInterval) clearInterval(timerInterval);
    timerDiv.textContent = '';
  }

  // Logging
  function logMove(text) {
    const li = document.createElement('li');
    li.textContent = text;
    moveList.appendChild(li);
    moveList.scrollTop = moveList.scrollHeight;
  }

  // Event listeners
modeSelect.addEventListener('change', () => {
  winsToWin = parseInt(winsToWinSelect.value);
  restartGame();
});
winsToWinSelect.addEventListener('change', () => {
  winsToWin = parseInt(winsToWinSelect.value);
  restartGame();
});

restartBtn.addEventListener('click', restartGame);
undoBtn.addEventListener('click', undoLastMove);

// Initialize
createBoard();
resetTimer();

</script>
</body>
</html>

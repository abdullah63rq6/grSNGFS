<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Purple Tic Tac Toe</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap');

  /* --- Body & Layout --- */
  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #5a2a83, #b892ff);
    color: #e6d4f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    user-select: none;
    overflow-x: hidden;
  }

  h1 {
    font-size: 3rem;
    margin: 20px 0 10px;
    text-shadow: 0 0 10px #d1b3ff;
    font-weight: 800;
  }

  /* --- Game Board --- */
  #game {
    display: grid;
    grid-template-columns: repeat(3, 130px);
    grid-template-rows: repeat(3, 130px);
    gap: 20px;
    background: rgba(255 255 255 / 0.1);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 0 40px 12px #5a2a83aa;
  }

  /* --- Cells --- */
  .cell {
    background: linear-gradient(145deg, #a67cff, #8a53d5);
    border-radius: 18px;
    box-shadow:
      inset 0 0 6px #fff8,
      0 8px 18px #5a2a83cc;
    font-size: 5rem;
    font-weight: 900;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    color: #d9b3ff;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    user-select: none;
    position: relative;
    overflow: hidden;
  }

  .cell:hover:not(.filled):not(.disabled) {
    transform: scale(1.1);
    box-shadow: 0 0 18px 5px #b991ffcc, inset 0 0 10px #c8aaff88;
  }

  .cell.x {
    color: #d1a3ff;
    text-shadow: 0 0 15px #c477ff;
    font-family: 'Segoe UI Symbol', sans-serif;
  }

  .cell.o {
    color: #512da8;
    text-shadow: 0 0 20px #7e57c2;
    font-family: 'Segoe UI Symbol', sans-serif;
  }

  /* --- Winning cells animation --- */
  .cell.winning {
    animation: pulseGlow 1.5s ease-in-out infinite;
    box-shadow: 0 0 25px 10px #bb86fc;
    color: #e0c3fc !important;
  }

  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 25px 10px #bb86fc; }
    50% { box-shadow: 0 0 40px 15px #d1a3ff; }
  }

  /* --- Controls Panel --- */
  #controls {
    margin: 25px 0;
    display: flex;
    gap: 20px;
    align-items: center;
  }

  label {
    font-weight: 700;
  }

  select, button {
    border: none;
    border-radius: 20px;
    padding: 8px 18px;
    font-weight: 700;
    cursor: pointer;
    background: #7e57c2;
    color: white;
    box-shadow: 0 5px 18px #5a2a83bb;
    transition: background-color 0.3s ease;
  }

  select:hover, button:hover {
    background-color: #512da8;
  }

  /* --- Modal for Game End --- */
  #endGameModal {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 320px;
    background: linear-gradient(145deg, #7e57c2, #b392ff);
    border-radius: 24px;
    padding: 28px;
    color: #fff;
    text-align: center;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    box-shadow: 0 0 20px 15px #5a2a83cc;
    transition: opacity 0.35s ease, transform 0.35s ease;
    z-index: 9999;
    user-select: none;
  }

  #endGameModal.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  #endGameModal button {
    margin-top: 20px;
    padding: 10px 25px;
    border: none;
    border-radius: 25px;
    background-color: #512da8;
    color: white;
    font-weight: 700;
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: 0 5px 18px #5a2a83bb;
    transition: background-color 0.3s ease;
  }

  #endGameModal button:hover {
    background-color: #7e57c2;
  }

  /* --- Confetti Canvas --- */
  #confetti-canvas {
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10000;
    width: 100vw;
    height: 100vh;
  }

  /* --- Responsive --- */
  @media(max-width: 480px) {
    #game {
      grid-template-columns: repeat(3, 90px);
      grid-template-rows: repeat(3, 90px);
      gap: 12px;
      padding: 15px;
    }
    .cell {
      font-size: 3.5rem;
      border-radius: 14px;
    }
  }
</style>
</head>
<body>

<h1>Ultimate Purple Tic Tac Toe</h1>

<div id="controls" aria-label="Game controls">
  <label for="difficulty">Difficulty:</label>
  <select id="difficulty" aria-controls="game" aria-label="Select AI difficulty">
    <option value="easy">Easy</option>
    <option value="medium" selected>Medium</option>
    <option value="hard">Hard</option>
  </select>
  <button id="undoBtn" aria-label="Undo last move" disabled>Undo</button>
  <button id="redoBtn" aria-label="Redo move" disabled>Redo</button>
  <button id="restartBtn" aria-label="Restart game">Restart</button>
</div>

<div id="game" role="grid" aria-label="Tic Tac Toe Board" tabindex="0">
  <!-- 9 cells -->
  <button class="cell" role="gridcell" aria-label="Row 1 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 1 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 1 Column 3" tabindex="0"></button>

  <button class="cell" role="gridcell" aria-label="Row 2 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 2 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 2 Column 3" tabindex="0"></button>

  <button class="cell" role="gridcell" aria-label="Row 3 Column 1" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 3 Column 2" tabindex="0"></button>
  <button class="cell" role="gridcell" aria-label="Row 3 Column 3" tabindex="0"></button>
</div>

<!-- End game modal -->
<div id="endGameModal" role="dialog" aria-modal="true" aria-labelledby="endGameMessage" tabindex="-1">
  <h2 id="endGameMessage"></h2>
  <button id="playAgainBtn">Play Again</button>
</div>

<!-- Confetti canvas -->
<canvas id="confetti-canvas" aria-hidden="true"></canvas>

<script>
  // --- Variables and Game State ---
  const cells = Array.from(document.querySelectorAll('.cell'));
  const game = document.getElementById('game');
  const difficultySelect = document.getElementById('difficulty');
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const restartBtn = document.getElementById('restartBtn');
  const modal = document.getElementById('endGameModal');
  const endGameMessage = document.getElementById('endGameMessage');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const confettiCanvas = document.getElementById('confetti-canvas');
  const ctx = confettiCanvas.getContext('2d');

  let board = Array(9).fill(null); // 'X' or 'O' or null
  let playerTurn = true; // player is 'X', AI is 'O'
  let gameActive = true;
  let moveHistory = [];
  let redoHistory = [];
  let currentDifficulty = difficultySelect.value;
  let winningLine = [];
  let confettiRunning = false;

  // Sounds (simple beep from web audio for demo)
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playBeep(frequency = 440, duration = 150) {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.type = 'sine';
    oscillator.frequency.value = frequency;
    oscillator.start();
    gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
    oscillator.stop(audioCtx.currentTime + duration / 1000);
  }

  // --- Confetti Particle System ---
  class ConfettiParticle {
    constructor(canvasWidth, canvasHeight) {
      this.x = Math.random() * canvasWidth;
      this.y = Math.random() * canvasHeight - canvasHeight;
      this.size = Math.random() * 6 + 4;
      this.gravity = 0.3 + Math.random() * 0.3;
      this.color = `hsl(${Math.random() * 270 + 240}, 90%, 80%)`; // purple hues
      this.rotation = Math.random() * 360;
      this.rotationSpeed = (Math.random() - 0.5) * 10;
      this.velocityX = (Math.random() - 0.5) * 2;
      this.velocityY = Math.random() * 2 + 1;
    }

    update() {
      this.velocityY += this.gravity;
      this.x += this.velocityX;
      this.y += this.velocityY;
      this.rotation += this.rotationSpeed;

      if (this.y > window.innerHeight) {
        this.x = Math.random() * window.innerWidth;
        this.y = -this.size;
        this.velocityY = Math.random() * 2 + 1;
      }
    }

    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation * Math.PI / 180);
      ctx.fillStyle = this.color;
      ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
      ctx.restore();
    }
  }

  let confettiParticles = [];

  function setupConfetti() {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    confettiParticles = Array.from({ length: 120 }, () => new ConfettiParticle(confettiCanvas.width, confettiCanvas.height));
  }
  setupConfetti();
  window.addEventListener('resize', setupConfetti);

  function runConfetti() {
    ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
    confettiParticles.forEach(p => {
      p.update();
      p.draw(ctx);
    });
    if (confettiRunning) requestAnimationFrame(runConfetti);
  }

  function startConfetti() {
    confettiRunning = true;
    runConfetti();
    setTimeout(() => { confettiRunning = false; ctx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); }, 5000);
  }

  // --- Game Logic ---

  // Winning combinations indices
  const winningCombos = [
    [0, 1, 2], [3, 4, 5],
    [6, 7, 8], [0, 3, 6],
    [1, 4, 7], [2, 5, 8],
    [0, 4, 8], [2, 4, 6]
  ];

  function checkWin(board, player) {
    for (const combo of winningCombos) {
      if (combo.every(i => board[i] === player)) {
        return combo;
      }
    }
    return null;
  }

  function checkDraw(board) {
    return board.every(cell => cell !== null);
  }

  function updateBoardUI() {
    cells.forEach((cell, idx) => {
      cell.textContent = board[idx] === 'X' ? '✕' : board[idx] === 'O' ? '◯' : '';
      cell.classList.remove('x', 'o', 'filled', 'winning', 'disabled');
      if (board[idx]) {
        cell.classList.add(board[idx].toLowerCase(), 'filled');
      }
      if (!gameActive) {
        cell.classList.add('disabled');
      }
    });
  }

  function highlightWinningCells(combo) {
    combo.forEach(i => cells[i].classList.add('winning'));
  }

  // --- Undo / Redo ---

  function updateUndoRedoButtons() {
    undoBtn.disabled = moveHistory.length === 0;
    redoBtn.disabled = redoHistory.length === 0;
  }

  // --- Player Move ---

  function playerMove(index) {
    if (!gameActive || board[index]) return false;
    board[index] = 'X';
    moveHistory.push({ board: [...board], player: 'X', index });
    redoHistory = [];
    playBeep(550);
    updateBoardUI();
    checkGameStatus('X');
    if (gameActive) {
      playerTurn = false;
      aiMove();
    }
    updateUndoRedoButtons();
    return true;
  }

  // --- AI Moves ---

  function aiMove() {
    setTimeout(() => {
      if (!gameActive) return;
      let moveIndex;
      switch (currentDifficulty) {
        case 'easy': moveIndex = easyAIMove(board, 'O'); break;
        case 'medium': moveIndex = mediumAIMove(board, 'O'); break;
        case 'hard': moveIndex = hardAIMove(board, 'O'); break;
        default: moveIndex = mediumAIMove(board, 'O');
      }
      board[moveIndex] = 'O';
      moveHistory.push({ board: [...board], player: 'O', index: moveIndex });
      playBeep(330);
      updateBoardUI();
      checkGameStatus('O');
      playerTurn = true;
      updateUndoRedoButtons();
    }, 700);
  }

  // AI Easy - random
  function easyAIMove(board, player) {
    let empty = board.map((v, i) => v === null ? i : null).filter(v => v !== null);
    return empty[Math.floor(Math.random() * empty.length)];
  }

  // AI Medium - block and win attempts
  function mediumAIMove(board, player) {
    // Win if possible
    for (let i = 0; i < 9; i++) {
      if (!board[i]) {
        board[i] = player;
        if (checkWin(board, player)) {
          board[i] = null;
          return i;
        }
        board[i] = null;
      }
    }
    // Block opponent
    let opponent = player === 'X' ? 'O' : 'X';
    for (let i = 0; i < 9; i++) {
      if (!board[i]) {
        board[i] = opponent;
        if (checkWin(board, opponent)) {
          board[i] = null;
          return i;
        }
        board[i] = null;
      }
    }
    // Pick center, corners, then sides
    const preferredMoves = [4, 0, 2, 6, 8, 1, 3, 5, 7];
    for (let move of preferredMoves) {
      if (!board[move]) return move;
    }
    // fallback random
    return easyAIMove(board, player);
  }

  // AI Hard - minimax algorithm
  function hardAIMove(board, player) {
    function minimax(newBoard, currentPlayer) {
      let availSpots = newBoard.map((v, i) => v === null ? i : null).filter(v => v !== null);

      let winComboX = checkWin(newBoard, 'X');
      let winComboO = checkWin(newBoard, 'O');
      if (winComboX) return { score: -10 };
      if (winComboO) return { score: 10 };
      if (availSpots.length === 0) return { score: 0 };

      let moves = [];
      for (let i = 0; i < availSpots.length; i++) {
        let move = {};
        move.index = availSpots[i];
        newBoard[availSpots[i]] = currentPlayer;

        if (currentPlayer === 'O') {
          let result = minimax(newBoard, 'X');
          move.score = result.score;
        } else {
          let result = minimax(newBoard, 'O');
          move.score = result.score;
        }
        newBoard[availSpots[i]] = null;
        moves.push(move);
      }

      let bestMove;
      if (currentPlayer === 'O') {
        let bestScore = -Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score > bestScore) {
            bestScore = moves[i].score;
            bestMove = moves[i];
          }
        }
      } else {
        let bestScore = Infinity;
        for (let i = 0; i < moves.length; i++) {
          if (moves[i].score < bestScore) {
            bestScore = moves[i].score;
            bestMove = moves[i];
          }
        }
      }
      return bestMove;
    }

    let bestMove = minimax(board, player);
    return bestMove.index;
  }

  // --- Check Game Status ---
  function checkGameStatus(currentPlayer) {
    const combo = checkWin(board, currentPlayer);
    if (combo) {
      gameActive = false;
      winningLine = combo;
      highlightWinningCells(combo);
      showEndGameModal(`${currentPlayer === 'X' ? 'You Win! 🎉' : 'AI Wins! 💻'}`);
      startConfetti();
      return true;
    } else if (checkDraw(board)) {
      gameActive = false;
      showEndGameModal("It's a Draw! 🤝");
      return true;
    }
    return false;
  }

  // --- End Game Modal ---
  function showEndGameModal(message) {
    endGameMessage.textContent = message;
    modal.classList.add('show');
    modal.focus();
  }
  function hideEndGameModal() {
    modal.classList.remove('show');
    game.focus();
  }

  // --- Undo ---
  function undoMove() {
    if (moveHistory.length === 0) return;
    let lastMove = moveHistory.pop();
    redoHistory.push(lastMove);
    if (moveHistory.length === 0) {
      board = Array(9).fill(null);
      gameActive = true;
      playerTurn = true;
    } else {
      board = [...moveHistory[moveHistory.length - 1].board];
      gameActive = true;
      playerTurn = moveHistory[moveHistory.length - 1].player === 'O';
    }
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  // --- Redo ---
  function redoMove() {
    if (redoHistory.length === 0) return;
    let nextMove = redoHistory.pop();
    moveHistory.push(nextMove);
    board = [...nextMove.board];
    gameActive = true;
    playerTurn = nextMove.player === 'O' ? false : true;
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  // --- Restart Game ---
  function restartGame() {
    board = Array(9).fill(null);
    playerTurn = true;
    gameActive = true;
    moveHistory = [];
    redoHistory = [];
    winningLine = [];
    updateBoardUI();
    updateUndoRedoButtons();
    hideEndGameModal();
  }

  // --- Event Listeners ---
  cells.forEach((cell, idx) => {
    cell.addEventListener('click', () => {
      if (playerTurn) playerMove(idx);
    });
    cell.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (playerTurn) playerMove(idx);
      }
    });
  });

  undoBtn.addEventListener('click', undoMove);
  redoBtn.addEventListener('click', redoMove);
  restartBtn.addEventListener('click', restartGame);
  difficultySelect.addEventListener('change', (e) => {
    currentDifficulty = e.target.value;
  });

  playAgainBtn.addEventListener('click', () => {
    restartGame();
  });

  // Accessibility: Trap focus inside modal when open
  modal.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      e.preventDefault();
      hideEndGameModal();
    }
    if (e.key === 'Tab') {
      // simple trap on the button only (one focusable element)
      e.preventDefault();
      playAgainBtn.focus();
    }
  });

  // Initial setup
  updateBoardUI();
  updateUndoRedoButtons();

</script>

</body>
</html>

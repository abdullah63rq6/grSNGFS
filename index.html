<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tic Tac Toe with Bot</title>
<style>
  body {
    font-family: Arial, sans-serif;
    margin: 20px;
  }
  #gameContainer {
    max-width: 600px;
    margin: auto;
    text-align: center;
  }
  #board {
    display: grid;
    margin: 20px auto;
    gap: 5px;
    user-select: none;
  }
  .cell {
    background: #f0f0f0;
    border: 1px solid #ccc;
    font-size: 2em;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    height: 60px;
    width: 60px;
  }
  .cell.blocked {
    background: #666;
    cursor: not-allowed;
  }
  #controls {
    margin-bottom: 10px;
  }
  button, select {
    margin: 5px;
    padding: 5px 10px;
  }
  #endGameModal {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 1.5em;
    z-index: 1000;
  }
  #endGameModal div {
    background: #333;
    padding: 20px;
    border-radius: 8px;
  }
  #scoreboard {
    margin-top: 10px;
    font-weight: bold;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <h1>Tic Tac Toe with Bot</h1>

  <div id="controls">
    <label for="playerCount">Players:</label>
    <select id="playerCount">
      <option value="1">1 (Player vs Player)</option>
      <option value="2" selected>2 (Player vs Player)</option>
    </select>

    <label>
      <input type="checkbox" id="playVsBot" /> Play vs Bot
    </label>

    <label for="botDifficulty">Bot Difficulty:</label>
    <select id="botDifficulty" disabled>
      <option value="easy">Easy</option>
      <option value="medium" selected>Medium</option>
      <option value="hard">Hard</option>
    </select>

    <label for="boardSize">Board Size:</label>
    <select id="boardSize">
      <option value="3" selected>3x3</option>
      <option value="4">4x4</option>
      <option value="5">5x5</option>
    </select>

    <button id="startBtn">Start Game</button>
    <button id="powerupBtn" disabled>Use Power-Up</button>
  </div>

  <div id="timer">Time left: <span id="timerValue">10</span>s</div>

  <div id="board"></div>

  <div id="scoreboard">Player 1: 0 | Player 2: 0</div>
</div>

<div id="endGameModal">
  <div>
    <div id="endGameMessage"></div>
    <button id="closeModalBtn">Close</button>
  </div>
</div>

<script>
(() => {
  const boardElem = document.getElementById('board');
  const startBtn = document.getElementById('startBtn');
  const powerupBtn = document.getElementById('powerupBtn');
  const playerCountSelect = document.getElementById('playerCount');
  const playVsBotCheckbox = document.getElementById('playVsBot');
  const botDifficultySelect = document.getElementById('botDifficulty');
  const boardSizeSelect = document.getElementById('boardSize');
  const timerElem = document.getElementById('timerValue');
  const scoreboardElem = document.getElementById('scoreboard');
  const endGameModal = document.getElementById('endGameModal');
  const endGameMessage = document.getElementById('endGameMessage');
  const closeModalBtn = document.getElementById('closeModalBtn');

  let board = [];
  let boardSize = 3;
  let playerCount = 2;
  let vsBot = false;
  let botDifficulty = 'medium';
  let currentPlayer = 0; // 0 or 1
  let movesMade = 0;
  let gameActive = false;
  let powerupsLeft = [1, 1]; // one powerup per player
  let blockedCells = new Set();
  let lastMoves = [null, null];
  let timerInterval = null;
  let timerValue = 10;

  // Setup event listeners for toggling bot mode and difficulty
  playVsBotCheckbox.addEventListener('change', () => {
    botDifficultySelect.disabled = !playVsBotCheckbox.checked;
    if (playVsBotCheckbox.checked) {
      playerCountSelect.value = 1;
      playerCountSelect.disabled = true;
    } else {
      playerCountSelect.disabled = false;
    }
  });

  startBtn.addEventListener('click', startGame);
  powerupBtn.addEventListener('click', usePowerup);
  closeModalBtn.addEventListener('click', () => endGameModal.style.display = 'none');

  function startGame() {
    vsBot = playVsBotCheckbox.checked;
    botDifficulty = botDifficultySelect.value;
    playerCount = vsBot ? 1 : parseInt(playerCountSelect.value);
    boardSize = parseInt(boardSizeSelect.value);

    createEmptyBoard();
    setupGrid();
    renderBoard();
    resetScoresIfNeeded();

    currentPlayer = 0;
    movesMade = 0;
    gameActive = true;
    powerupsLeft = [1, 1];
    blockedCells.clear();
    lastMoves = [null, null];
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;

    startTimer();
    hideEndGameModal();

    if (vsBot && currentPlayer === 1) {
      botMove();
    }
  }

  function createEmptyBoard() {
    board = new Array(boardSize * boardSize).fill(null);
  }

  function setupGrid() {
    boardElem.style.gridTemplateColumns = `repeat(${boardSize}, 60px)`;
    boardElem.style.gridTemplateRows = `repeat(${boardSize}, 60px)`;
    boardElem.innerHTML = '';
    for (let i = 0; i < board.length; i++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = i;
      cell.addEventListener('click', handleCellClick);
      boardElem.appendChild(cell);
    }
  }

  function renderBoard() {
    for (let i = 0; i < board.length; i++) {
      const cell = boardElem.children[i];
      cell.textContent = board[i] === 0 ? 'X' : board[i] === 1 ? 'O' : '';
      if (blockedCells.has(i)) {
        cell.classList.add('blocked');
        cell.textContent = 'â– ';
        cell.style.color = '#333';
      } else {
        cell.classList.remove('blocked');
        cell.style.color = '#000';
      }
    }
  }

  function handleCellClick(e) {
    if (!gameActive) return;
    const idx = Number(e.target.dataset.index);
    if (board[idx] !== null || blockedCells.has(idx)) return;
    if (vsBot && currentPlayer === 1) return; // Ignore clicks on bot's turn

    makeMove(idx);
  }

  function makeMove(idx) {
    if (board[idx] !== null || blockedCells.has(idx)) return;

    board[idx] = currentPlayer;
    lastMoves[currentPlayer] = idx;
    movesMade++;

    renderBoard();
    updateScoreboard();

    if (checkWin(idx, currentPlayer)) {
      gameActive = false;
      showEndGameModal(`Player ${currentPlayer + 1} wins!`);
      powerupBtn.disabled = true;
      if (vsBot && currentPlayer === 1) launchConfetti();
      stopTimer();
      return;
    }

    if (movesMade >= boardSize * boardSize) {
      gameActive = false;
      showEndGameModal("It's a tie!");
      powerupBtn.disabled = true;
      stopTimer();
      return;
    }

    currentPlayer = (currentPlayer + 1) % (vsBot ? 2 : playerCount);
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    resetTimer();

    if (vsBot && currentPlayer === 1) {
      botMove();
    }
  }

  function checkWin(lastIdx, player) {
    const row = Math.floor(lastIdx / boardSize);
    const col = lastIdx % boardSize;

    // Check row
    let win = true;
    for (let c = 0; c < boardSize; c++) {
      if (board[row * boardSize + c] !== player) {
        win = false;
        break;
      }
    }
    if (win) return true;

    // Check column
    win = true;
    for (let r = 0; r < boardSize; r++) {
      if (board[r * boardSize + col] !== player) {
        win = false;
        break;
      }
    }
    if (win) return true;

    // Check main diagonal if applicable
    if (row === col) {
      win = true;
      for (let i = 0; i < boardSize; i++) {
        if (board[i * boardSize + i] !== player) {
          win = false;
          break;
        }
      }
      if (win) return true;
    }

    // Check anti diagonal if applicable
    if (row + col === boardSize - 1) {
      win = true;
      for (let i = 0; i < boardSize; i++) {
        if (board[i * boardSize + (boardSize - 1 - i)] !== player) {
          win = false;
          break;
        }
      }
      if (win) return true;
    }

    return false;
  }

  // Power-up blocks the last move of opponent
  function usePowerup() {
    if (powerupsLeft[currentPlayer] <= 0 || !gameActive) return;
    const opponent = (currentPlayer + 1) % (vsBot ? 2 : playerCount);
    const opponentLastMove = lastMoves[opponent];
    if (opponentLastMove === null || blockedCells.has(opponentLastMove)) return;

    blockedCells.add(opponentLastMove);
    powerupsLeft[currentPlayer]--;
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    renderBoard();
    // Immediately switch turn
    currentPlayer = opponent;
    resetTimer();

    if (vsBot && currentPlayer === 1) {
      botMove();
    }
  }

  // Timer functions
  function startTimer() {
    timerValue = 10;
    timerElem.textContent = timerValue;
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
      timerValue--;
      timerElem.textContent = timerValue;
      if (timerValue <= 0) {
        clearInterval(timerInterval);
        skipTurn();
      }
    }, 1000);
  }

  function resetTimer() {
    startTimer();
  }

  function stopTimer() {
    if (timerInterval) clearInterval(timerInterval);
  }

  // If timer runs out, skip turn
  function skipTurn() {
    if (!gameActive) return;
    currentPlayer = (currentPlayer + 1) % (vsBot ? 2 : playerCount);
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    startTimer();

    if (vsBot && currentPlayer === 1) {
      botMove();
    }
  }

  function updateScoreboard() {
    // Placeholder, could be extended to keep scores over multiple rounds
    scoreboardElem.textContent = `Player 1: ${powerupsLeft[0]} power-up(s) left | Player 2: ${powerupsLeft[1]} power-up(s) left`;
  }

  function showEndGameModal(message) {
    endGameMessage.textContent = message;
    endGameModal.style.display = 'flex';
  }

  function hideEndGameModal() {
    endGameModal.style.display = 'none';
  }

  function resetScoresIfNeeded() {
    powerupsLeft = [1, 1];
    updateScoreboard();
  }

  // Bot AI moves
  function botMove() {
    if (!gameActive || currentPlayer !== 1) return;

    setTimeout(() => {
      let moveIndex;
      if (botDifficulty === 'easy') {
        moveIndex = getRandomMove();
      } else if (botDifficulty === 'medium') {
        moveIndex = getMediumMove();
      } else if (botDifficulty === 'hard') {
        moveIndex = getHardMove();
      }
      if (moveIndex !== null) {
        makeMove(moveIndex);
      }
    }, 1000);
  }

  function getAvailableMoves() {
    return board.map((val, idx) => (val === null && !blockedCells.has(idx) ? idx : null))
                .filter(v => v !== null);
  }

  function getRandomMove() {
    const moves = getAvailableMoves();
    if (moves.length === 0) return null;
    return moves[Math.floor(Math.random() * moves.length)];
  }

  // Medium: Try to win, block, else random
  function getMediumMove() {
    const moves = getAvailableMoves();
    if (moves.length === 0) return null;

    // Try to win
    for (const idx of moves) {
      board[idx] = 1;
      if (checkWin(idx, 1)) {
        board[idx] = null;
        return idx;
      }
      board[idx] = null;
    }
    // Block opponent
    for (const idx of moves) {
      board[idx] = 0;
      if (checkWin(idx, 0)) {
        board[idx] = null;
        return idx;
      }
      board[idx] = null;
    }
    return getRandomMove();
  }

  // Hard: Minimax with alpha-beta pruning
  function getHardMove() {
    const best = minimax(board.slice(), 1, true, 0, -Infinity, Infinity);
    return best.index;
  }

  function minimax(boardState, player, isMaximizing, depth, alpha, beta) {
    const moves = boardState.map((val, idx) => (val === null && !blockedCells.has(idx) ? idx : null))
                            .filter(v => v !== null);

    // Check terminal
    for (const idx of [...Array(boardState.length).keys()]) {
      if (boardState[idx] !== null) {
        if (checkWinForMinimax(boardState, idx, 0)) return { score: -10 + depth, index: null };
        if (checkWinForMinimax(boardState, idx, 1)) return { score: 10 - depth, index: null };
      }
    }
    if (moves.length === 0) return { score: 0, index: null };

    let bestMove = { score: isMaximizing ? -Infinity : Infinity, index: null };

    for (const idx of moves) {
      boardState[idx] = player;
      const scoreObj = minimax(boardState, 1 - player, !isMaximizing, depth + 1, alpha, beta);
      boardState[idx] = null;

      if (isMaximizing) {
        if (scoreObj.score > bestMove.score) {
          bestMove.score = scoreObj.score;
          bestMove.index = idx;
        }
        alpha = Math.max(alpha, scoreObj.score);
      } else {
        if (scoreObj.score < bestMove.score) {
          bestMove.score = scoreObj.score;
          bestMove.index = idx;
        }
        beta = Math.min(beta, scoreObj.score);
      }

      if (beta <= alpha) break;
    }

    return bestMove;
  }

  // Check win for minimax on arbitrary board
  function checkWinForMinimax(boardState, lastIdx, player) {
    const size = boardSize;
    const row = Math.floor(lastIdx / size);
    const col = lastIdx % size;

    let win = true;
    for (let c = 0; c < size; c++) {
      if (boardState[row * size + c] !== player) {
        win = false;
        break;
      }
    }
    if (win) return true;

    win = true;
    for (let r = 0; r < size; r++) {
      if (boardState[r * size + col] !== player) {
        win = false;
        break;
      }
    }
    if (win) return true;

    if (row === col) {
      win = true;
      for (let i = 0; i < size; i++) {
        if (boardState[i * size + i] !== player) {
          win = false;
          break;
        }
      }
      if (win) return true;
    }

    if (row + col === size - 1) {
      win = true;
      for (let i = 0; i < size; i++) {
        if (boardState[i * size + (size - 1 - i)] !== player) {
          win = false;
          break;
        }
      }
      if (win) return true;
    }

    return false;
  }

  // Simple confetti effect
  function launchConfetti() {
    const duration = 2 * 1000;
    const animationEnd = Date.now() + duration;
    const colors = ['#bb0000', '#ffffff'];

    (function frame() {
      const timeLeft = animationEnd - Date.now();

      if (timeLeft <= 0) return;

      const confetti = document.createElement('div');
      confetti.style.position = 'fixed';
      confetti.style.zIndex = '9999';
      confetti.style.left = Math.random() * window.innerWidth + 'px';
      confetti.style.top = '-10px';
      confetti.style.width = '10px';
      confetti.style.height = '10px';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.borderRadius = '50%';
      confetti.style.opacity = '0.7';
      confetti.style.pointerEvents = 'none';
      document.body.appendChild(confetti);

      let pos = -10;
      const fallInterval = setInterval(() => {
        pos += 5;
        confetti.style.top = pos + 'px';
        if (pos > window.innerHeight) {
          clearInterval(fallInterval);
          confetti.remove();
        }
      }, 20);

      requestAnimationFrame(frame);
    })();
  }

  // Initialize defaults
  startGame();
})();
</script>
</body>
</html>

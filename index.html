<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ultimate Purple Tic Tac Toe - Advanced</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@700&display=swap');

  /* --- Body & Layout --- */
  body {
    margin: 0;
    font-family: 'Poppins', sans-serif;
    background: linear-gradient(135deg, #5a2a83, #b892ff);
    color: #e6d4f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    user-select: none;
    overflow-x: hidden;
    padding: 15px;
  }

  h1 {
    font-size: 3rem;
    margin: 20px 0 5px;
    text-shadow: 0 0 10px #d1b3ff;
    font-weight: 800;
  }

  /* --- Controls --- */
  #controls {
    margin: 15px 0 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
    justify-content: center;
    max-width: 600px;
  }

  label {
    font-weight: 700;
    user-select: none;
  }

  select, button {
    border: none;
    border-radius: 20px;
    padding: 8px 18px;
    font-weight: 700;
    cursor: pointer;
    background: #7e57c2;
    color: white;
    box-shadow: 0 5px 18px #5a2a83bb;
    transition: background-color 0.3s ease;
    user-select: none;
  }

  select:hover:not(:disabled), button:hover:not(:disabled) {
    background-color: #512da8;
  }

  button:disabled {
    background-color: #9e8cd9;
    cursor: default;
  }

  /* --- Scoreboard --- */
  #scoreboard {
    margin-bottom: 12px;
    display: flex;
    gap: 15px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .player-score {
    background: rgba(255 255 255 / 0.15);
    padding: 8px 14px;
    border-radius: 18px;
    min-width: 80px;
    text-align: center;
    font-weight: 700;
    user-select: none;
    display: flex;
    flex-direction: column;
    align-items: center;
    color: #e6d4f0;
  }
  .player-symbol {
    font-size: 1.7rem;
    font-weight: 900;
    margin-bottom: 3px;
  }
  .level-badge {
    margin-top: 4px;
    background: #d1a3ffaa;
    padding: 1px 7px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
    color: #3c1164;
  }

  /* --- Timer Display --- */
  #timer {
    margin: 10px 0 18px;
    font-size: 1.4rem;
    font-weight: 700;
    user-select: none;
  }

  /* --- Power-up Button --- */
  #powerupBtn {
    background: #b77aff;
    color: #3c1164;
    font-weight: 800;
    border-radius: 24px;
    padding: 10px 20px;
    box-shadow: 0 6px 18px #5a2a83cc;
    transition: background-color 0.3s ease;
  }
  #powerupBtn:hover:not(:disabled) {
    background-color: #7d3aff;
    color: #e6d4f0;
  }
  #powerupBtn:disabled {
    background-color: #a387d2;
    cursor: default;
    color: #5a2a83;
  }

  /* --- Game Board --- */
  #game {
    display: grid;
    gap: 15px;
    background: rgba(255 255 255 / 0.1);
    border-radius: 20px;
    padding: 25px;
    box-shadow: 0 0 40px 12px #5a2a83aa;
    user-select: none;
  }

  /* dynamic grid size will be set by JS */

  /* --- Cells --- */
  .cell {
    background: linear-gradient(145deg, #a67cff, #8a53d5);
    border-radius: 18px;
    box-shadow:
      inset 0 0 6px #fff8,
      0 8px 18px #5a2a83cc;
    font-size: 4rem;
    font-weight: 900;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    color: #d9b3ff;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.4s ease;
    user-select: none;
    position: relative;
    overflow: hidden;
  }
  .cell.blocked {
    background: #442a6d;
    cursor: default;
  }
  .cell:hover:not(.filled):not(.disabled):not(.blocked) {
    transform: scale(1.1);
    box-shadow: 0 0 18px 5px #b991ffcc, inset 0 0 10px #c8aaff88;
  }

  /* --- Player colors and fonts --- */
  .player-0 { color: #d1a3ff; text-shadow: 0 0 15px #c477ff; font-family: 'Segoe UI Symbol', sans-serif; }
  .player-1 { color: #512da8; text-shadow: 0 0 20px #7e57c2; font-family: 'Segoe UI Symbol', sans-serif; }
  .player-2 { color: #ffbb55; text-shadow: 0 0 18px #d18c00; font-family: 'Segoe UI Symbol', sans-serif; }
  .player-3 { color: #66ffcc; text-shadow: 0 0 20px #0fa885; font-family: 'Segoe UI Symbol', sans-serif; }

  /* --- Winning cells animation --- */
  .cell.winning {
    animation: pulseGlow 1.5s ease-in-out infinite;
    box-shadow: 0 0 25px 10px #bb86fc;
    color: #e0c3fc !important;
  }

  @keyframes pulseGlow {
    0%, 100% { box-shadow: 0 0 25px 10px #bb86fc; }
    50% { box-shadow: 0 0 40px 15px #d1a3ff; }
  }

  /* --- Disabled cells --- */
  .cell.disabled {
    cursor: default;
  }

  /* --- Modal for Game End --- */
  #endGameModal {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 320px;
    background: linear-gradient(145deg, #7e57c2, #b392ff);
    border-radius: 24px;
    padding: 28px;
    color: #fff;
    text-align: center;
    transform: translate(-50%, -50%) scale(0);
    opacity: 0;
    box-shadow: 0 0 20px 15px #5a2a83cc;
    transition: opacity 0.35s ease, transform 0.35s ease;
    z-index: 9999;
    user-select: none;
  }

  #endGameModal.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  #endGameModal button {
    margin-top: 20px;
    padding: 10px 25px;
    border: none;
    border-radius: 25px;
    background-color: #512da8;
    color: white;
    font-weight: 700;
    font-size: 1.2rem;
    cursor: pointer;
    box-shadow: 0 5px 18px #5a2a83bb;
    transition: background-color 0.3s ease;
  }

  #endGameModal button:hover {
    background-color: #7e57c2;
  }

  /* --- Confetti Canvas --- */
  #confetti-canvas {
    position: fixed;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 10000;
    width: 100vw;
    height: 100vh;
  }

  /* --- Responsive --- */
  @media(max-width: 480px) {
    #game {
      gap: 8px;
      padding: 15px;
    }
    .cell {
      font-size: 2.6rem;
      border-radius: 14px;
    }
  }
</style>
</head>
<body>

<h1>Ultimate Purple Tic Tac Toe</h1>

<!-- Scoreboard -->
<div id="scoreboard" aria-label="Players scoreboard">
  <!-- Filled dynamically -->
</div>

<!-- Timer display -->
<div id="timer" aria-live="polite" aria-atomic="true" role="status"></div>

<!-- Controls -->
<div id="controls" aria-label="Game controls">
  <label for="boardSize">Board Size:</label>
  <select id="boardSize" aria-label="Select board size">
    <option value="3" selected>3x3</option>
    <option value="4">4x4</option>
    <option value="5">5x5</option>
  </select>

  <label for="playerCount">Players:</label>
  <select id="playerCount" aria-label="Select number of players">
    <option value="2" selected>2</option>
    <option value="3">3
        <option value="4">4</option>
  </select>

  <button id="startBtn" aria-label="Start new game">Start Game</button>
  <button id="powerupBtn" aria-label="Use power-up" disabled>Use Power-Up</button>
</div>

<!-- Game Board -->
<div id="game" role="grid" aria-label="Tic Tac Toe Board"></div>

<!-- End Game Modal -->
<div id="endGameModal" role="dialog" aria-modal="true" aria-labelledby="endGameTitle" tabindex="-1">
  <h2 id="endGameTitle"></h2>
  <button id="restartBtn" aria-label="Restart game">Play Again</button>
</div>

<!-- Confetti Canvas -->
<canvas id="confetti-canvas"></canvas>

<script>
(() => {
  'use strict';

  // --- Constants ---
  const PLAYER_SYMBOLS = [
    ['\u2715', '\u2A2F'],    // X, variant for player 1
    ['\u25EF', '\u25CB'],    // O, variant for player 2
    ['\u2605', '\u272D'],    // Star symbols for player 3
    ['\u25B2', '\u25BC']     // Triangle symbols for player 4
  ];

  const PLAYER_COLORS = ['#d1a3ff', '#512da8', '#ffbb55', '#66ffcc'];

  const WIN_LEVELS = [0, 3, 5, 8]; // Levels unlocked at these win counts

  const MOVE_TIME_LIMIT = 15; // seconds per move

  // --- DOM Elements ---
  const gameBoard = document.getElementById('game');
  const startBtn = document.getElementById('startBtn');
  const powerupBtn = document.getElementById('powerupBtn');
  const boardSizeSelect = document.getElementById('boardSize');
  const playerCountSelect = document.getElementById('playerCount');
  const scoreboard = document.getElementById('scoreboard');
  const timerDisplay = document.getElementById('timer');
  const endGameModal = document.getElementById('endGameModal');
  const endGameTitle = document.getElementById('endGameTitle');
  const restartBtn = document.getElementById('restartBtn');
  const confettiCanvas = document.getElementById('confetti-canvas');

  // --- Game State ---
  let boardSize = 3;
  let playerCount = 2;
  let board = [];
  let currentPlayer = 0;
  let movesMade = 0;
  let moveTimer = null;
  let moveTimeLeft = MOVE_TIME_LIMIT;
  let lastMoves = []; // store last move index per player for power-up erase
  let powerupsLeft = []; // power-up count per player
  let blockedCells = new Set();
  let scores = [];
  let gameActive = false;

  // Confetti animation state
  let confettiCtx, confettiWidth, confettiHeight, confettiPieces;

  // --- Setup ---

  // Initialize scoreboard and scores
  function initScores() {
    scores = Array(playerCount).fill(0);
    powerupsLeft = Array(playerCount).fill(1); // 1 power-up per player
    lastMoves = Array(playerCount).fill(null);
    updateScoreboard();
  }

  // Update scoreboard UI
  function updateScoreboard() {
    scoreboard.innerHTML = '';
    for(let i = 0; i < playerCount; i++) {
      const div = document.createElement('div');
      div.className = 'player-score';
      div.style.color = PLAYER_COLORS[i];
      div.innerHTML = `
        <div class="player-symbol player-${i}">${PLAYER_SYMBOLS[i][0]}</div>
        <div>Player ${i+1}</div>
        <div>Wins: ${scores[i]}</div>
        <div class="level-badge">${getLevelBadge(scores[i])}</div>
        <div>Power-Ups: ${powerupsLeft[i]}</div>
      `;
      scoreboard.appendChild(div);
    }
  }

  // Return badge text based on wins
  function getLevelBadge(wins) {
    if (wins >= WIN_LEVELS[3]) return 'Legend ð';
    if (wins >= WIN_LEVELS[2]) return 'Pro â­';
    if (wins >= WIN_LEVELS[1]) return 'Rookie ð°';
    return 'Newbie';
  }

  // Generate empty board array
  function createEmptyBoard() {
    board = Array(boardSize * boardSize).fill(null);
    blockedCells.clear();
  }

  // Create grid style dynamically based on board size
  function setupGrid() {
    gameBoard.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
    gameBoard.style.gridTemplateRows = `repeat(${boardSize}, 1fr)`;
  }

  // Render board cells
  function renderBoard() {
    gameBoard.innerHTML = '';
    for(let i = 0; i < board.length; i++) {
      const cell = document.createElement('button');
      cell.className = 'cell';
      cell.setAttribute('role', 'gridcell');
      cell.setAttribute('aria-label', `Cell ${Math.floor(i/boardSize)+1}, ${i % boardSize + 1}`);
      cell.dataset.index = i;

      if(blockedCells.has(i)) {
        cell.classList.add('blocked');
        cell.disabled = true;
      }

      if(board[i] !== null) {
        cell.textContent = PLAYER_SYMBOLS[board[i]][0];
        cell.classList.add('filled', `player-${board[i]}`);
        cell.disabled = true;
      }

      gameBoard.appendChild(cell);
    }
  }

  // Start move timer
  function startTimer() {
    clearInterval(moveTimer);
    moveTimeLeft = MOVE_TIME_LIMIT;
    updateTimerDisplay();
    moveTimer = setInterval(() => {
      moveTimeLeft--;
      updateTimerDisplay();
      if(moveTimeLeft <= 0) {
        clearInterval(moveTimer);
        alert(`Time's up for Player ${currentPlayer + 1}! Turn skipped.`);
        nextTurn();
      }
    }, 1000);
  }

  // Update timer UI
  function updateTimerDisplay() {
    timerDisplay.textContent = `Player ${currentPlayer + 1} (${PLAYER_SYMBOLS[currentPlayer][0]}) time left: ${moveTimeLeft}s`;
    timerDisplay.style.color = PLAYER_COLORS[currentPlayer];
  }

  // Handle player move (click on cell)
  function handleCellClick(e) {
    if (!gameActive) return;
    const idx = parseInt(e.target.dataset.index);
    if(board[idx] !== null || blockedCells.has(idx)) return;

    makeMove(idx, currentPlayer);
  }

  // Make a move and update board
  function makeMove(idx, player) {
    board[idx] = player;
    lastMoves[player] = idx;
    movesMade++;
    renderBoard();

    if(checkWin(idx, player)) {
      // Win!
      scores[player]++;
      updateScoreboard();
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal(`Player ${player + 1} Wins!`);
      launchConfetti();
    } else if(movesMade >= board.length - blockedCells.size) {
      // Tie
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal(`It's a Tie!`);
    } else {
      // Possibly block a random empty cell every 5 moves
      if (movesMade % 5 === 0) {
        blockRandomCell();
      }
      nextTurn();
    }
  }

  // Switch to next player and start timer
  function nextTurn() {
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    currentPlayer = (currentPlayer + 1) % playerCount;

    // Skip players who can't play (all cells blocked or no moves)
    let looped = 0;
    while(looped < playerCount && isPlayerStuck(currentPlayer)) {
      currentPlayer = (currentPlayer + 1) % playerCount;
      looped++;
    }
    if(looped === playerCount) {
      // No moves possible for anyone
      gameActive = false;
      clearInterval(moveTimer);
      showEndGameModal("No moves left! It's a Tie!");
      return;
    }
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    updateTimerDisplay();
    startTimer();
  }

  // Check if player can make a move (any empty non-blocked cell)
  function isPlayerStuck(player) {
    return board.every((val, idx) => val !== null || blockedCells.has(idx));
  }

  // Check winning condition for last move
  function checkWin(idx, player) {
    const row = Math.floor(idx / boardSize);
    const col = idx % boardSize;

    // Win condition depends on board size:
    // For 3x3: 3 in a row, 4x4: 4 in a row, 5x5: 5 in a row
    const winLength = boardSize;

    function countDirection(dx, dy) {
      let count = 1;
      // forward
      for(let step = 1; step < winLength; step++) {
        const nx = col + dx*step;
        const ny = row + dy*step;
        if(nx < 0 || ny < 0 || nx >= boardSize || ny >= boardSize) break;
        if(board[ny*boardSize + nx] === player) count++;
        else break;
      }
      // backward
      for(let step = 1; step < winLength; step++) {
        const nx = col - dx*step;
        const ny = row - dy*step;
        if(nx < 0 || ny < 0 || nx >= boardSize || ny >= boardSize) break;
        if(board[ny*boardSize + nx] === player) count++;
        else break;
      }
      return count;
    }

    // Directions: horizontal, vertical, diagonal1, diagonal2
    if(countDirection(1, 0) >= winLength) return true;
    if(countDirection(0, 1) >= winLength) return true;
    if(countDirection(1, 1) >= winLength) return true;
    if(countDirection(1, -1) >= winLength) return true;

    return false;
  }

  // Show game end modal
  function showEndGameModal(message) {
    endGameTitle.textContent = message;
    endGameModal.classList.add('show');
    endGameModal.focus();
    powerupBtn.disabled = true;
  }

  // Hide end game modal and restart game
  function hideEndGameModal() {
    endGameModal.classList.remove('show');
  }

  // Block a random empty cell temporarily
  function blockRandomCell() {
    const emptyIndices = [];
    for(let i = 0; i < board.length; i++) {
      if(board[i] === null && !blockedCells.has(i)) emptyIndices.push(i);
    }
    if(emptyIndices.length === 0) return;

    const toBlock = emptyIndices[Math.floor(Math.random() * emptyIndices.length)];
    blockedCells.add(toBlock);
    renderBoard();

    // Unblock after 2 moves
    let unblockCounter = 2;
    const unblockInterval = setInterval(() => {
      unblockCounter--;
      if(unblockCounter <= 0) {
        blockedCells.delete(toBlock);
        renderBoard();
        clearInterval(unblockInterval);
      }
    }, MOVE_TIME_LIMIT * 1000); // Approx 2 turns
  }

  // Use power-up: erase opponent's last move
  function usePowerUp() {
    if(powerupsLeft[currentPlayer] <= 0) return;
    // Find opponent last move to erase
    let erased = false;
    for(let p = 0; p < playerCount; p++) {
      if(p !== currentPlayer) {
        const idx = lastMoves[p];
        if(idx !== null && board[idx] === p) {
          board[idx] = null;
          lastMoves[p] = null;
          movesMade--;
          erased = true;
          break;
        }
      }
    }
    if(erased) {
      powerupsLeft[currentPlayer]--;
      updateScoreboard();
      renderBoard();
      powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
      // Player can now make move again, so reset timer
      clearInterval(moveTimer);
      moveTimeLeft = MOVE_TIME_LIMIT;
      updateTimerDisplay();
      startTimer();
    } else {
      alert('No opponent moves to erase!');
    }
  }

  // --- Confetti animation (simple) ---
  function launchConfetti() {
    if(!confettiCtx) {
      confettiCtx = confettiCanvas.getContext('2d');
      resizeConfetti();
      window.addEventListener('resize', resizeConfetti);
    }
    confettiPieces = [];
    for(let i = 0; i < 150; i++) {
      confettiPieces.push({
        x: Math.random() * confettiWidth,
        y: Math.random() * confettiHeight - confettiHeight,
        size: Math.random() * 7 + 4,
        speedY: Math.random() * 3 + 2,
        speedX: (Math.random() - 0.5) * 2,
        color: PLAYER_COLORS[Math.floor(Math.random() * playerCount)],
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 10,
      });
    }
    requestAnimationFrame(confettiLoop);
    setTimeout(() => {
      confettiPieces = [];
      confettiCtx.clearRect(0, 0, confettiWidth, confettiHeight);
    }, 5000);
  }

  function resizeConfetti() {
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    confettiWidth = confettiCanvas.width;
    confettiHeight = confettiCanvas.height;
  }

  function confettiLoop() {
    if (!confettiPieces || confettiPieces.length === 0) return;
    confettiCtx.clearRect(0, 0, confettiWidth, confettiHeight);

    for(let piece of confettiPieces) {
      confettiCtx.save();
      confettiCtx.fillStyle = piece.color;
      confettiCtx.translate(piece.x, piece.y);
      confettiCtx.rotate(piece.rotation * Math.PI / 180);
      confettiCtx.fillRect(-piece.size/2, -piece.size/2, piece.size, piece.size/2);
      confettiCtx.restore();

      piece.y += piece.speedY;
      piece.x += piece.speedX;
      piece.rotation += piece.rotationSpeed;

      if(piece.y > confettiHeight) piece.y = -piece.size;
      if(piece.x > confettiWidth) piece.x = 0;
      if(piece.x < 0) piece.x = confettiWidth;
    }
    requestAnimationFrame(confettiLoop);
  }

  // --- Event Listeners ---

  // Start game button
  startBtn.addEventListener('click', () => {
    boardSize = parseInt(boardSizeSelect.value);
    playerCount = parseInt(playerCountSelect.value);

    initScores();
    createEmptyBoard();
    setupGrid();
    renderBoard();

    currentPlayer = 0;
    movesMade = 0;
    gameActive = true;
    powerupBtn.disabled = powerupsLeft[currentPlayer] <= 0;
    updateTimerDisplay();
    startTimer();

    hideEndGameModal();
  });

  // Restart game from modal
  restartBtn.addEventListener('click', () => {
    endGameModal.classList.remove('show');
    startBtn.click();
  });

  // Board clicks for moves
  gameBoard.addEventListener('click', handleCellClick);

  // Power-up usage
  powerupBtn.addEventListener('click', () => {
    if (!gameActive) return;
    usePowerUp();
  });

  // Keyboard accessibility: allow Enter/Space on cells
  gameBoard.addEventListener('keydown', (e) => {
    if(e.key === 'Enter' || e.key === ' ') {
      e.preventDefault();
      if(e.target.classList.contains('cell')) {
        e.target.click();
      }
    }
  });

  // --- Initialize ---
  boardSize = parseInt(boardSizeSelect.value);
  playerCount = parseInt(playerCountSelect.value);
  initScores();
  createEmptyBoard();
  setupGrid();
  renderBoard();
  timerDisplay.textContent = 'Press Start Game to play!';

})();
</script>

</body>
</html>
